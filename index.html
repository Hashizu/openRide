<!doctype html>
<html class="no-js" lang="ja">
<head>
    <title>Air Ride</title>
    <script src="./libs/three.js"></script>
    <script src="./libs/dat.gui.min.js"></script>
    <script src="./libs/stats.min.js"></script>
    <script src="./libs/tween.js"></script>
    <style>
        body {
            /* set margin to 0 and overflow to hidden, to go fullscreen */
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>
	<body>
	 <div id="target1">
		 </div>
</body>
<script>

    // global variables
    var renderer,scene,camera,stats;

    var projector = new THREE.Projector();
    var mouse = { x: 0, y: 0 };
    var mup=false,mdown=false;
    var count=0;
    var xsp=3,ysp=0;    //初速度
    var gravity = 0.02; //重力
    var cube;
    var pi = Math.PI;
    var game = true;  //true = in game


    var isTweening = false;

    function createPlayer() {
        var cubeGeometry = new THREE.BoxGeometry(5, 2, 5);
        var cubeMaterial = createPlayerMaterial();
        cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
        //cube.castShadow = true;
        cube.name = 'cube';
        cube.position = new THREE.Vector3(-100, 10, 0);
        scene.add(cube);
        return cube;
    }
    function createFloor(x,y,z,rot){
      var planeGeometry = new THREE.PlaneGeometry(600, 800, 100, 100);
      var planeMaterial = new THREE.MeshLambertMaterial({color: 0xffffff});
      var plane = new THREE.Mesh(planeGeometry, planeMaterial);
      plane.receiveShadow = true;
      plane.rotation.x = -0.5 * pi * rot;

      plane.position.x = x;
      plane.position.y = y;
      plane.position.z = z;
      scene.add(plane);
      return plane;
    }
    function createPlayerMaterial() {
        var earthTexture = THREE.ImageUtils.loadTexture("./assets/textures/wood_1-1024x1024.png");
        var earthMaterial = new THREE.MeshBasicMaterial();
        earthMaterial.map = earthTexture;
        return earthMaterial;
    }
    /**
     * Initializes the scene, camera and objects. Called when the window is
     * loaded by using window.onload (see below)
     */
    function init() {

        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        renderer = new THREE.WebGLRenderer();
        renderer.setClearColor(0xeeeeee, 1.0);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMapEnabled = true;

        var cube = createPlayer();
        var plane = createFloor(0,0,0,1);
        console.log("x座標:"+cube.position.x+"  y座標:"+cube.position.y+"  z座標:"+cube.position.z);
        camera.position.x = -100;
        camera.position.y = 10;
        camera.position.z = 80;
        camera.lookAt(new THREE.Vector3(0, 0, -10000));

        var spotLight = new THREE.SpotLight(0xffffff);
        spotLight.position.set(0, 600, 10);
        spotLight.shadowCameraNear = 100;
        spotLight.shadowCameraFar = 20;
        spotLight.castShadow = true;
        scene.add(spotLight);

        addStatsObject();
        // add the output of the renderer to the html element
        document.body.appendChild(renderer.domElement);
        // call the render function, after the first render, interval is determined
        // by requestAnimationFrame

        render();
    }

    /**cube goes to {vx,vy} at time in thier vercity**/

    var tempx,tempy,k,ek,vz,tx,ty;
    function goFoward(cube, vx, vy, time) {

        if (!isTweening) {
          tempx=vx,tempy=vy;
          k = Math.sqrt(tempx*tempx+tempy*tempy);
          el = Math.atan(tempy/tempx);
          vz = cube.rotation.z;
            if(tempx<0 && tempy>0)
            el+=pi/2;
          else if(tempx<0 && tempy<0)
            el+=pi;
          else if(tempx<0 && tempy<0)
            el+=3*pi/2;
          if(vz<0)
            vz+=2*pi;
          tx =k*Math.cos(vz+el);
          ty =k*Math.sin(vz+el);
          tx = normal(tx);
          ty = normal(ty);

          var target = {x:vx,y:vy,t:tx};
          var previous = {x:0,y:0,t:0};
          var tween = new TWEEN.Tween( {cube: cube} )
                  .to( target, time )
                  .easing(TWEEN.Easing.Linear.None)
                  .onStart(function() {
                      isTweening = true;

                  })
                  .onUpdate( function () {
                      cube.geometry.applyMatrix(new THREE.Matrix4().makeTranslation((this.x - previous.x),(this.y - previous.y),0));
                      cube.geometry.verticesNeedUpdate = true;
                      cube.geometry.normalsNeedUpdate = true;
                      camera.position.x += this.t-previous.t;
                      previous.x = this.x;
                      previous.y = this.y;
                      previous.t = this.t;

                  })
                  .onComplete(function() {

                    cube.position.x+=tx;
                    cube.position.y+=ty;
                    cube.geometry.applyMatrix(new THREE.Matrix4().makeTranslation(-target.x,-target.y,0));
                    console.log("vx: "+vx+" vy: "+vy);
                    console.log("x: "+cube.position.x+" y: "+cube.position.y);
                    //camera.position.x = cube.position.x;
                      isTweening = false;
                  })
                  .start();

        }
    }

    function addStatsObject() {
        stats = new Stats();
        stats.setMode(0);
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.left = '0px';
        stats.domElement.style.top = '0px';

        document.body.appendChild( stats.domElement );
    }

    /**
     * Called when the scene needs to be rendered. Delegates to requestAnimationFrame
     * for future renders
     */

     function render() {

       if(game)
        frameUpdate();
       gameCheck();


       stats.update();
       TWEEN.update();
       renderer.render(scene, camera);
       requestAnimationFrame(render);
    }

    function gameCheck(){
      if(game&&cube.position.y<0){
        alert("   Landing!!!\nScore: "+normal(cube.position.x+100)+"m");
        game = false;
      }

    }


    function frameUpdate(){
      var cube = scene.getObjectByName('cube');
      if (!isTweening) {
        if(mup && cube.rotation.z < 2*pi/5){
          scene.getObjectByName('cube').rotation.z += 0.005*pi;
        }
        else if(-pi/2<pi){
          scene.getObjectByName('cube').rotation.z += -0.005*pi;
        }

        var vz = cube.rotation.z;
        if(vz<0){
          vz+= pi*2;
        }
          xsp += -normal(gravity * Math.sin(vz));
          ysp += -normal(gravity * Math.cos(vz));
      }
      goFoward(cube, xsp, ysp, 10);
    }

    function normal(nor){
      return Math.round(nor*100000)/100000;
    }

    /**
     * Function handles the resize event. This make sure the camera and the renderer
     * are updated at the correct moment.
     */
    function handleResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // calls the init function when the window is done loading.
    window.onload = init;
    // calls the handleResize function when the window is resized
    window.addEventListener('resize', handleResize, false);

    /** mouse click on upper then mup = true **/
    window.onmousedown = function (ev){
        if (ev.target == renderer.domElement) {

            //マウス座標2D変換
            var rect = ev.target.getBoundingClientRect();
            mouse.x =  ev.clientX - rect.left;
            mouse.y =  ev.clientY - rect.top;
            var vector = new THREE.Vector3( mouse.x, mouse.y ,1);
            if(vector.y <  window.innerHeight/2){   //when upper side click
                console.log("click upper side x: "+vector.x+" y: "+vector.y);
                mup = true;
            }else{
                mdown = true;
            }
        }
    }
    window.onmouseup = function(ev){
        console.log("mouse up");
        mup =false;
        mdown = false;
    };
    /** touch on upper then mup = true **/
	  document.body.addEventListener( "touchstart", function( event ) {
		var touchObject = event.changedTouches[0] ;
		var x = touchObject.pageX ;
		var y = touchObject.pageY ;
		var vector = new THREE.Vector3( x, y ,1);
		 if(vector.y <  window.innerHeight/2){   //when upper side click
			console.log("click upper side x: "+vector.x+" y: "+vector.y);
			mup = true;
		}else{
			mdown = true;
		}
	} ) ;
	  document.body.addEventListener( "touchend", function( event ) {
		mup =false;
		mdown = false;

	});

</script>

</html>
